---
title: "BBI single cell data analysis tutorial"
host: Brotman Baty Institute Single-cell Bioinformatics Team
date: "February 9, 2021"
output: pdf_document
---

**Contacts**
aishwarya.gogate@seattlechildrens.org, hpliner@uw.edu


#################################################################################################
Structure of the tutorial:
#1. Main content

#2. Bonus questions
These are questions you should attempt during the tutorial.

#3. Challenge question
These questions are difficult! You do not have all the information you need provided - you'll need
to find further information on the internet. Attempt these if you're ahead in the tutorial exercises.
#################################################################################################

## Useful links for getting help:

# Website links
Monocle 3 website: https://cole-trapnell-lab.github.io/monocle3/

# Submit bug reports
Submit Monocle 3 bug reports on the Monocle 3 github repository: https://github.com/cole-trapnell-lab/monocle3

# Ask technical questions
Post Monocle 3 questions on the google group: https://groups.google.com/g/monocle-3-users

##########################################################################################
##########################################################################################

## The Monocle 3 pipeline
## Load Monocle 3 and other required packages
### Note: You must have Monocle 3 already installed
```{r echo=FALSE, results="hide", error=FALSE, message=FALSE, warning=FALSE}
library(monocle3)
library(ggplot2)
library(dplyr)
```

#################################################################################################
# A few preliminaries
#################################################################################################

## Load the cds object
```{r load, echo=FALSE}
#Function 1:
#expression_matrix <- readRDS(url("http://staff.washington.edu/hpliner/data/cao_l2_expression.rds"))
#cell_metadata <- readRDS(url("http://staff.washington.edu/hpliner/data/cao_l2_colData.rds"))
#gene_annotation <- readRDS(url("http://staff.washington.edu/hpliner/data/cao_l2_rowData.rds"))

#cds <- new_cell_data_set(expression_matrix,
                         cell_metadata = cell_metadata,
                         gene_metadata = gene_annotation)

#Function 2: load_mm_data
#This function helps to load data from count matrices that are in the matrix market format (.mtx files).
```

## Another option is to read in pre-made cds files
```{r echo=TRUE}
#cds1 <- readRDS('~/Downloads/cds1.RDS')
#cds2 <- readRDS('~/Downloads/cds2.RDS')

# Here I'm reading in the Sentinel human brain cds:
cds <- readRDS('~/Downloads/Sentinel_cds.RDS')
```

# If you need to combine multiple cds objects, use the combine_cds function
```{r echo=TRUE}
#cds <- combine_cds(list(cds1=cds1, cds2=cds2))
```

## Test out the accessor functions
```{r echo=FALSE}
cds
head(colData(cds))
head(rowData(cds))
head(counts(cds))
```

#################################################################################################
# You get back your data, now what? Try some things!
#################################################################################################

### Q1. How many "good" cells do I have?

What do good cells look like?
A. high UMI count (but not too high)
B. low mitochondrial reads
C. singlets

## A. DEAL WITH UMI COUNT FILTERING
## Remove cells with low UMI counts in one of two ways
```{r echo=FALSE}
# If you have BBI returned data, there will already be a n.umi column in the colData(cds), with a default cut off of 100.
cds <- cds[,colData(cds)$n.umi > 150]

# OR

# First, add a column in colData called n.umi
#colData(cds)$n.umi <- Matrix::colSums(counts(cds))
#cds <- cds[,Matrix::colSums(counts(cds)) > 150]


# Plot the distribution of UMIs
qplot(colData(cds)$n.umi, geom="density")
qplot(log10(colData(cds)$n.umi), geom="density")

# You can further filter for unreasonably high UMI counts (could often indicate leaking)
# Hint: Look at summary(colData(cds)$n.umi) and decide your cut-offs
# For eg:
#cds <- cds[,colData(cds)$n.umi < 50000]


## B. DEAL WITH HIGH MITOCHONDRIAL READ %
# You can then filter for high mito %
# Hint: Look at summary(colData(cds)$perc_mitochondrial_umis) and decide your cut-offs
# For eg:
#cds <- cds[,colData(cds)$perc_mitochondrial_umis < 10]


## C. DEAL WITH DOUBLETS
# You can further filter for doublets from your dataset
# Hint: Either look for the dip in the doublet score histogram to decide your cutoff or manually adjust/set a threshold.

# Beware: This could be a bit tricky!!
Salient features of doublet calling with Scrublet:
- simulated doublet histogram is typically bimodal
- the left mode corresponds to "embedded" doublets generated by two cells with similar gene expression
- the right mode corresponds to "neotypic" doublets which are generated by cells with distinct gene expression (e.g., different cell types)
- Scrublet can only detect neotypic doublets
- To call doublets vs. singlets you must set a threshold doublet score
- This is ideally at the minimum (dip/valley) between the two modes of the simulated doublet histogram

# What about when things aren't so ideal?? Eg: the histogram isn't bimodal
- you can use the calculated scrublet scores to manually set a threshold
- then plot the scrublet calls on a UMAP and gauge (is the stringiness among the clusters clearing?)
- this may take a few attempts

# I'm going to ditch all doublets using the scrublet_call column
cds <- cds[,!is.na(colData(cds)$scrublet_call) & colData(cds)$scrublet_call == "Singlet"]

# Alternately, you can filter using the scrublet_score column
#qplot(colData(cds)$scrublet_score, geom="density")
#cds <- cds[,colData(cds)$scrublet_score < 0.20]

Note: The data can have either all singlets, all doublets, singlets & doublets or NAs (when scrublet fails - not enough cells)

```

## CHALLENGE:
1. What's the distribution of mitochondrial genome reads in your data?
Hint: How do you know which genes are mitochondrial?

2. If you don't have pre-made scrublet_score & scrublet_call columns in your cds, how can you filter for doublets?
Hint: Check out scrublet tool here: https://github.com/AllonKleinLab/scrublet

You can also visit the page below to learn the step-by-step process of calling & filtering doublets:
https://github.com/AllonKleinLab/scrublet/blob/master/examples/scrublet_basics.ipynb


#################################################################################################

### Q2. How many "types" of cells do I have?

## Pre-process the cds
### Note: This step normalizes the data and runs PCA
```{r echo=FALSE}

cds <- preprocess_cds(cds)
plot_pc_variance_explained(cds)

# If you see that the majority of variance isn't explained in the
# plot, you can increase the number of PCA dimensions like this:
# cds <- preprocess_cds(cds, num_dim=100)
#
# For most datasets, the default of 50 will be sufficient

```

## Run UMAP to get low dimension representation and visualize
```{r echo=FALSE}
cds <- reduce_dimension(cds)
cds <- detect_genes(cds)

# Quick check: what does the detect_genes function do?
# Check the colData and rowData to find out!
head(colData(cds))
head(rowData(cds))

plot_cells(cds)
```

## Cluster cells and visualize the clusters and partitions
### Note: Partitions are basically super-clusters
```{r echo=FALSE}
cds <- cluster_cells(cds)
colData(cds)$cluster = clusters(cds)
head(partitions(cds, reduction_method = "UMAP"))
head(clusters(cds, reduction_method = "UMAP"))
plot_cells(cds)
plot_cells(cds, color_cells_by="partition", group_cells_by="partition")
plot_cells(cds, color_cells_by="cluster", group_cells_by="cluster")

## Lets do some more plotting!
# If you have a combined cds with several samples, you can colour the UMAP by sample
#plot_cells(cds, color_cells_by = "sample")

colData(cds)$log_n.umi <- log10(colData(cds)$n.umi)
plot_cells(cds, color_cells_by = "log_n.umi")
plot_cells(cds, color_cells_by = "scrublet_call")
plot_cells(cds, color_cells_by = "scrublet_score")

# Note: color_cells_by must use one of 'cluster', 'partition', 'pseudotime, or a column in the colData table.

```

## Plot the expression of some genes
```{r echo=TRUE, error=FALSE, message=FALSE, warning=FALSE}
# Astrocytes
plot_cells(cds, genes = c("GFAP", "S100B", "ALDH1L1", "SLC1A3", "SLC7A10", "FGFR3"))

# Neuron
plot_cells(cds, genes = c("RBFOX3", "ELAVL4", "SYP", "DLG4", "NEFM", "NEFH"))

```

# Bonus question:
What if I don't like my clustering? How can I change it?
Hint: What parameters are available for the cluster_cells function? (Try running ?cluster_cells)
```{r echo = FALSE}
cds <- cluster_cells(cds, resolution=1e-5)
plot_cells(cds)
```

## Bonus question:
Can you try plotting other genes of importance to you?

## CHALLENGE:
How different is the clustering if you use tSNE instead of UMAP?


#################################################################################################
A SHORT BREAK
##################################################################################################

### Q3. What are the identities of the cell types?
If you are exploring, you can use top_markers to determine which genes are specific to each cluster and use these to generate a marker file.

## Find top marker genes for each cluster
```{r echo=FALSE}
marker_genes <- top_markers(cds, genes_to_test_per_group = 10, group_cells_by = "cluster")
head(marker_genes)
```

## Subset the top most significant markers based on q-value
```{r echo=FALSE}
top_sig <- subset(marker_genes, marker_test_q_value < .05)

```

## Rank & plot genes based on a specificity marker (eg: pseudo_R2) from the marker_genes table
```{r echo=FALSE}
top_specific_markers <- marker_genes %>%
                            filter(fraction_expressing >= 0.10) %>%
                            group_by(cell_group) %>%
                            top_n(1, pseudo_R2)

top_specific_marker_ids <- unique(top_specific_markers %>% pull(gene_short_name))

plot_genes_by_group(cds,
                    top_specific_marker_ids,
                    group_cells_by="cluster",
                    ordering_type="maximal_on_diag",
                    max.size=3)

```

## You can also generate marker file to input into Garnett (for cell type annotation)
```{r echo=FALSE}
generate_garnett_marker_file(marker_genes)

# Now check your marker genes and see where they're expressed!
```

Bonus question:
Can you rank & plot genes based on a different specificity marker from the marker_genes table?

## CHALLENGE:
Can you pull expression data from the marker_genes table and plot the expression of the top 50 genes from each cluster as a violin plot?

##################################################################################################

##For further understanding:

## Detailed steps
In order to identify specific clusters of genes, compare the clusters, perform differential expression analysis and trajectory analysis, we use the Monocle 3 package [link](https://cole-trapnell-lab.github.io/monocle3/). This package provides a toolkit for analyzing single-cell gene expression experiments.

Given below is the description of each step of the Monocle 3 workflow:

## Step 0: QC and filter your data to ensure that good quality data goes into downstream analysis.

## Step 1: Normalize and pre-process the data
Monocle 3 first normalizes the expression values to account for technical variation in the RNA recovery and sequencing depth.

## Step 2: Dimensionality reduction
In order to eliminate noise and make further analysis more tractable, Monocle 3 projects the cells onto the top 50 (default) principal components. You can then choose whether to carry out further non-linear dimensionality reduction either by t-SNE or UMAP methods. Monocle 3 then clusters the cells and further organizes them into trajectories if desired.

## Step 3: Cluster and partition cells
Monocle 3 can learn if cells should be placed in the same trajectory or not through its clustering step. It cleverly detects if some cells are part of a different process than others in the dataset and will therefore build different trajectories simultaneously from a single dataset. This is done by partitioning the cells into super-clusters. Each super-cluster can have smaller distinct clusters. Cells from different super-clusters can be a part of the same trajectory.
Once the cells are clustered you can ask what genes makes them different from one another (find top markers) and can compare clusters to identify targeted contrasts. You can also identify the type of each cell in the data by clustering and then assigning a cell type to each cluster based on its gene expression profile.

## Step 4: Find top marker genes in clusters
Once cells have been clustered, this step helps to ask what genes make them different from one another.

## Step 5: Differential expression analysis and visualization
This step helps to find genes that are differentially expressed between groups of cells and across a trajectory. Its useful in finding genes that vary across cells of different types, are collected at different time points, or have been perturbed in different ways.

## Step 6: Trajectory analysis
This step organizes each super-cluster into a trajectory. It learns the principal graph and then assigns a pseudotime value to each cell. This step is especially useful in case of time-series or progression data where each time point could potentially be a trajectory branch.

## BBI pipeline deliverables shared with collaborators via Globus##
* **01-raw_fastq**: Raw sequence files in FASTQ format
* **02-alignment_bam**: Alignment files in BAM format
* **03-sample_cds.Rds**: cds object for your single-cell experiment
* **04-umi_counts.matrix**: Numeric matrix of xpression values where rows are genes and columns are cells
* **05-gene_annotations.txt**: A dataframe where rows are features (e.g. genes), and columns are gene attributes
* **06-cell_annotations.txt**: A dataframe where rows are cells and columns are cell attributes
* **07-alignment_stats.txt**: File with alignment/mapping statistics
* **08-duplication_stats.txt**: File with duplication statistics
* **09-SampleIDMap.csv**: Map of your sample IDs to the internal BAT lab sample IDs
* **10-dashboard.html**: Investigator dashboard

##################################################################################################
